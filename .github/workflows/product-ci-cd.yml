name: Product CI/CD

on:
#  push:
#    branches:
#      - main
#    paths:
#      - 'product/**'
#      - '.github/workflows/product-ci-cd.yml'
#      - 'build.gradle'
#      - 'settings.gradle'
#      - '.dockerignore'
#  pull_request:
#    paths:
#      - 'product/**'
#      - '.github/workflows/product-ci-cd.yml'
#      - 'build.gradle'
#      - 'settings.gradle'
#      - '.dockerignore'
  workflow_dispatch:
    
    

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/beadv2_2_dev_high_be/product
  SERVICE_NAME: product-service
  NAMESPACE: ${{ vars.K8S_NAMESPACE || 'default' }}

jobs:
#  test:
#    runs-on: ubuntu-latest
#    steps:
#      - name: Checkout
#        uses: actions/checkout@v4
#
#      - name: Set up JDK
#        uses: actions/setup-java@v4
#        with:
#          distribution: temurin
#          java-version: 17
#          cache: gradle
#
#      - name: Run product tests
#        run: |
#          chmod +x gradlew
#          ./gradlew :product:test

  build-and-push:
#    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.deploy_ref || 'main' }}

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17
          cache: gradle

      - name: Build product bootJar
        run: |
          chmod +x gradlew
          ./gradlew :product:bootJar

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: product/Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

  deploy:
    needs: build-and-push
#    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.deploy_ref || 'main' }}

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4

      - name: Configure kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config
      

      - name: Ensure GHCR imagePullSecret exists
        run: | #secret 존재하면 덮어쓰기, 없으면 새로 생성. 도커 레지스트리(secret)에 ghcr 접근관련 정보제공, --dry-run=client -o yaml은 리소스 안남김
          kubectl create secret docker-registry ghcr-secret \
            --namespace ${{ env.NAMESPACE }} \
            --docker-server=${{ env.REGISTRY }} \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.GITHUB_TOKEN }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create or update product secret # secret으로부터 env 불러오기
        run: | 
          kubectl create secret generic product-secret \
          --namespace ${{ env.NAMESPACE }} \
          --from-literal=SPRING_DATASOURCE_URL="${{secrets.SPRING_DATASOURCE_URL}}" \
          --from-literal=SPRING_DATASOURCE_DRIVER="${{secrets.SPRING_DATASOURCE_DRIVER}}" \
          --from-literal=SPRING_DATASOURCE_USERNAME="${{secrets.SPRING_DATASOURCE_USERNAME}}" \
          --from-literal=SPRING_DATASOURCE_PASSWORD="${{secrets.SPRING_DATASOURCE_PASSWORD}}" \
          --from-literal=JWT_SECRET="${{secrets.JWT_SECRET}}" \
          --from-literal=JWT_ACCESS_TOKEN_EXPIRATION="${{secrets.JWT_ACCESS_TOKEN_EXPIRATION}}" \
          --from-literal=JWT_REFRESH_TOKEN_EXPIRATION="${{secrets.JWT_REFRESH_TOKEN_EXPIRATION}}" \
          --from-literal=MORE_MAIL_USERNAME="${{secrets.MORE_MAIL_USERNAME}}" \
          --from-literal=MORE_MAIL_PASSWORD="${{secrets.MORE_MAIL_PASSWORD}}" \
          --from-literal=KAFKA_BOOTSTRAP_SERVERS="${{secrets.KAFKA_BOOTSTRAP_SERVERS}}" \
          --from-literal=KAFKA_BOOT_PORT="${{secrets.KAFKA_BOOT_PORT}}" \
          --from-literal=KAFKA_USER="${{secrets.KAFKA_USER}}" \
          --from-literal=KAFKA_PASSWORD="${{secrets.KAFKA_PASSWORD}}" \
          --from-literal=ELASTIC_SEARCH_URL="${{secrets.ELASTIC_SEARCH_URL}}" \
          --from-literal=REDIS_HOST="${{secrets.REDIS_HOST}}" \
          --from-literal=REDIS_PORT="${{secrets.REDIS_PORT}}" \
          --from-literal=TOSS_SECRET_KEY="${{secrets.TOSS_SECRET_KEY}}" \
          --from-literal=AWS_ACCESS_KEY_ID="${{secrets.AWS_ACCESS_KEY_ID}}" \
          --from-literal=AWS_SECRET_ACCESS_KEY="${{secrets.AWS_SECRET_ACCESS_KEY}}" \
          --from-literal=GPT_API_KEY="${{secrets.GPT_API_KEY}}" \
          --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy
        env:
          IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        run: |
          kubectl set image --local -f product/k8s/deployment.yaml \
            $SERVICE_NAME=$IMAGE -o yaml | kubectl apply -f - -n $NAMESPACE
          kubectl apply -f product/k8s/service.yaml -n $NAMESPACE
          kubectl rollout status deployment/$SERVICE_NAME -n $NAMESPACE
